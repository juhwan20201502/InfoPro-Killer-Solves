# C/Java 핵심 자료구조 및 OOP 풀이 (Core CS Solutions)

C/Java의 핵심 '킬러' 개념(포인터, 자료구조, 상속, OOP)을 '이해'하고 '증명'하기 위한 풀이 모음입니다.

## 1. C언어 - 연결 리스트 (Stack 구현)

(파일: `TSEB.c`)

### 1-1. 핵심 개념

* C언어 `struct` 포인터, `malloc` (동적 할당), `free` (메모리 해제)를 이용한 '자료구조' 구현 문제입니다.
* "코드를 '읽는' 능력(70% 실력)"을 증명하는 문제입니다.

### 1-2. 로직 분석 (TSEB의 비밀)

1.  **'거꾸로 쌓기' (Stack):** `func("BEST")`는 "B->E->S->T" 순서가 아니라, `n->p = h; h = n;` 로직을 통해 "T->S->E->B" 순서(스택)로 리스트를 '거꾸로' 쌓습니다.
2.  **'헤드(h)' 포인터:** `func`가 반환하는 `h`는 'B'가 아니라, 'T' 노드(최종 헤드)를 가리킵니다.
3.  **'순차 출력' (Traversal):** `main`의 `while(n)`문은 `h`('T' 노드)부터 `n = n->p;`로 '다음 칸'을 순회하며 `putchar`로 'T', 'S', 'E', 'B'를 순서대로 출력합니다.
4.  **'free' (메모리 해제):** `putchar`로 '출력'하고, `free(t)`로 '반납(삭제)'합니다. ('free'는 '출력'이 아닙니다.)

### 1-3. 결론

* **최종 답:** `TSEB`
* **증명된 스킬:** C언어 `struct` 포인터 연산, `malloc/free`를 통한 '동적 메모리 관리', '연결 리스트'의 '스택' 자료구조 구현 능력.

## 2. Java - OOP 상속 ('리모콘' 3가지 규칙)

(파일: `HeroZilean.java`)

### 2-1. 핵심 개념

* Java '상속'과 '다형성(Polymorphism)'에서, '리모콘'(변수 타입)과 '실제 객체'(new)가 다를 때 발생하는 '킬러' 함정 문제입니다.
* "코드를 '읽는' 능력(70% 실력)"을 증명하는 문제입니다.

### 2-2. '리모콘 3가지 규칙' 분석 (영웅/질리언의 비밀)

`Hero h = new Zilean();` (리모콘: `Hero`, 객체: `Zilean`)

1.  **'변수' (`h.name`)는 '리모콘'을 따른다.**
    * '변수'(`name`)는 오버라이딩(Overriding) 대상이 아닙니다.
    * '리모콘' 타입인 `Hero`의 `name`("영웅")을 참조합니다.
    * **결과: `영웅`**

2.  **'`static` 메서드'는 '리모콘'을 따른다.**
    * `static` 메서드 또한 오버라이딩 대상이 아닙니다.
    * '리모콘' 타입의 `static` 메서드를 참조합니다.

3.  **'`non-static` 메서드' (`h.getName()`)만 '실제 객체'를 따른다.**
    * 'non-static 메서드'만이 유일하게 '오버라이딩' 대상입니다.
    * '실제 객체'인 `Zilean`의 `getName()`을 참조합니다.
    * **결과: `질리언`**

### 2-3. 결론

* **최종 답:** `영웅` (줄바꿈) `질리언`
* **증명된 스킬:** Java '상속'과 '다형성'의 3가지 규칙(변수, static, non-static)을 '이해'하는 OOP(객체 지향) 구현 능력.
